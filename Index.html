<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Well Completions</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for both plot containers */
        .plotly-chart-container {
            width: 100%;
            min-height: 450px;
        }
        input[type="file"], input[type="number"], input[type="text"], button {
            cursor: pointer;
        }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 30px; height: 30px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Style disabled state for sections */
        fieldset:disabled { opacity: 0.5; cursor: not-allowed; }
        fieldset:disabled input, fieldset:disabled button { cursor: not-allowed; }
        #markerSection:disabled button:not(#addMarkerButton),
        #titleSection:disabled button, #printButton:disabled {
            background-color: #9ca3af !important; border-color: #9ca3af !important; color: #e5e7eb !important;
        }
        #markerSection:disabled #addMarkerButton { background-color: #9ca3af !important; }
        button:disabled { opacity: 0.6 !important; cursor: not-allowed !important; }
        button:disabled:hover { filter: brightness(100%); }

        /* --- Print Styles --- */
         @media print {
            body * { visibility: hidden; }
            /* Make printable area and its direct children visible */
            #printableArea, #printableArea > * { visibility: visible; }
             /* Make contents within plot containers visible */
            #printableArea .plotly-chart-container, #printableArea .plotly-chart-container * { visibility: visible; }
            #printableArea { position: absolute; left: 0; top: 0; width: 100%; height: auto; padding: 10px; margin: 0; }
            .plotly-chart-container, .plotly-chart-container .plot-container, .plotly-chart-container .svg-container {
                 width: 100% !important; height: 45vh !important; min-height: 300px; page-break-inside: avoid;
            }
             #plotlyChart2 { margin-top: 20px; }
            .no-print { display: none !important; }
            body { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; background-color: #fff !important; padding: 0 !important; }
            h2.plot-title { color: #000 !important; text-align: center; margin-bottom: 5px; font-size: 16px; }
             .legend { print-color-adjust: exact !important; }
         }
         /* --- END: Print Styles --- */
    </style>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
</head>
<body class="bg-gray-100 p-8">

    <div class="bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-semibold mb-4 text-center text-gray-800 no-print">Interactive Completions Plot</h1>

        <div class="no-print space-y-6 mb-6">
            <div class="border-b pb-6">
                <label for="fileInput" class="block text-sm font-medium text-gray-700 mb-2">1. Upload survey file in .xlsx format:</label>
                <input type="file" id="fileInput" accept=".xlsx" class="block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold
                    file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                <p class="mt-1 text-xs text-gray-500">Requires columns named as: 'TVD', 'MD', 'DLS', 'Depth', 'Plug #'.</p>
            </div>

            <div class="border-b pb-6">
                 <button id="printButton" disabled class="px-4 py-2 bg-gray-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 disabled:bg-gray-300 disabled:text-gray-500">
                    Print Plot Area
                </button>
            </div>

            <fieldset id="titleSection" class="border-b pb-6" disabled>
                <label class="block text-sm font-medium text-gray-700 mb-2">Edit Plot Title (Top Plot):</label>
                <div class="flex items-center space-x-2">
                    <input type="text" id="plotTitleInput" placeholder="Enter plot title" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    <button id="updateTitleButton" class="px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 whitespace-nowrap">
                        Update Title
                    </button>
                </div>
            </fieldset>

            <fieldset id="markerSection" disabled>
                 <label class="block text-sm font-medium text-gray-700 mb-2">Add/Remove Marker/Comment (Top Plot):</label>
                 <div class="grid grid-cols-1 sm:grid-cols-3 gap-2 items-end mb-2">
                     <div>
                        <label for="mdValueInput" class="block text-xs font-medium text-gray-500">MD Value:</label>
                        <input type="number" id="mdValueInput" placeholder="Enter MD" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                     </div>
                     <div class="sm:col-span-1">
                         <label for="markerTextInput" class="block text-xs font-medium text-gray-500">Comment (Optional):</label>
                         <input type="text" id="markerTextInput" placeholder="Enter text for marker" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                     </div>
                     <div>
                        <button id="addMarkerButton" class="w-full px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 whitespace-nowrap">
                            Add Marker
                        </button>
                     </div>
                 </div>
                 <div class="flex justify-between items-center mt-2">
                     <p id="markerStatus" class="text-xs text-gray-500 h-4 flex-grow"></p>
                     <div class="flex space-x-2">
                         <button id="removeLastMarkerButton" disabled class="px-3 py-1 bg-yellow-500 text-white text-xs font-medium rounded-md shadow-sm hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-400 disabled:bg-gray-300 disabled:text-gray-500">
                             Remove Last
                         </button>
                         <button id="removeAllMarkersButton" disabled class="px-3 py-1 bg-red-600 text-white text-xs font-medium rounded-md shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 disabled:bg-gray-300 disabled:text-gray-500">
                             Remove All
                         </button>
                     </div>
                 </div>
            </fieldset>

             <div id="status" class="text-center h-6"></div>
             <div id="errorBox" class="hidden p-4 bg-red-100 border border-red-400 text-red-700 rounded-md">
                <p id="errorMessage"></p>
             </div>
        </div>
        <div id="printableArea">
            <h2 id="htmlPlotTitle" class="text-xl font-semibold mb-2 text-center text-gray-700 plot-title"></h2>
            <div id="plotlyChart" class="plotly-chart-container border rounded-lg bg-gray-50 mb-6">
                <div class="flex items-center justify-center h-full text-gray-500">
                    Upload an XLSX file to generate the plot.
                </div>
            </div>

            <h2 id="htmlPlotTitle2" class="text-xl font-semibold mb-2 text-center text-gray-700 plot-title"></h2>
            <div id="plotlyChart2" class="plotly-chart-container border rounded-lg bg-gray-50">
                 <div class="flex items-center justify-center h-full text-gray-500"></div> </div>
        </div>
        <footer class="mt-8 pt-4 border-t border-gray-200 text-center no-print">
            <p class="text-xs text-gray-500">
                This application visualizes well completion data. The top plot shows the well path (MD vs TVD) with optional completion markers and allows adding custom annotations. The bottom plot highlights points with DLS > 5 via automatic annotations, colored by DLS value.
                <br> Author: Javier Fonseca.
            </p>
        </footer>

    </div>
    <script>
        console.log("Plotter script loaded (v37 - Controls Top Layout).");

        // --- DOM Elements ---
        const fileInput = document.getElementById('fileInput');
        const plotDiv = document.getElementById('plotlyChart'); // Plot 1 container
        const plotDiv2 = document.getElementById('plotlyChart2'); // Plot 2 container
        const statusDiv = document.getElementById('status');
        const errorBox = document.getElementById('errorBox');
        const errorMessage = document.getElementById('errorMessage');
        const titleSection = document.getElementById('titleSection');
        const plotTitleInput = document.getElementById('plotTitleInput');
        const updateTitleButton = document.getElementById('updateTitleButton');
        const htmlPlotTitle = document.getElementById('htmlPlotTitle'); // Plot 1 title
        const htmlPlotTitle2 = document.getElementById('htmlPlotTitle2'); // Plot 2 title
        const markerSection = document.getElementById('markerSection');
        const mdValueInput = document.getElementById('mdValueInput');
        const markerTextInput = document.getElementById('markerTextInput');
        const addMarkerButton = document.getElementById('addMarkerButton');
        const markerStatus = document.getElementById('markerStatus');
        const removeLastMarkerButton = document.getElementById('removeLastMarkerButton');
        const removeAllMarkersButton = document.getElementById('removeAllMarkersButton');
        const printButton = document.getElementById('printButton');

        // --- Global State ---
        let plotInstance = null; // Plot 1 instance
        let plotInstance2 = null; // Plot 2 instance
        let currentPlotData = { lineData: [], nearestPointsData: {}, dlsHighlightData: [], dlsSuperHighlightData: [], dlsRange: { min: null, max: null } };
        let currentLayout = {}; // Plot 1 layout
        let currentLayout2 = {}; // Plot 2 layout
        let lastMarkerPosition = { md: null, tvd: null };
        let lastMarkerAyOffset = -40;
        let lastAutoMarkerPosition = { md: null, tvd: null };
        let lastAutoMarkerAyOffset = -40;

        // --- Utility Functions ---
        function showLoading(message = "Loading...") { /* ... */ }
        function clearLoading(message = "") { /* ... */ }
        function showError(message, errorObj = null) { /* ... */ }
        function hideError() { /* ... */ }
        function resetStaggeringState() { /* ... */ }
        function resetAutoStaggeringState() { /* ... */ }
        function updateRemoveButtonsState() { /* ... */ }
        function clearPlot() { /* ... */ }

        // --- Utility Functions (Full Implementation) ---
        function showLoading(message = "Loading...") {
            statusDiv.innerHTML = `<div class="flex items-center justify-center text-blue-600"><div class="loader mr-2"></div><span>${message}</span></div>`;
            // console.log("Loading:", message);
        }
        function clearLoading(message = "") {
             statusDiv.innerHTML = message ? `<span class="text-green-600">${message}</span>` : '';
             // if(message) console.log("Status:", message);
        }
        function showError(message, errorObj = null) {
            errorMessage.textContent = message;
            errorBox.classList.remove('hidden');
            console.error("Error:", message, errorObj || '');
        }
        function hideError() {
            errorBox.classList.add('hidden');
            errorMessage.textContent = '';
        }
        function resetStaggeringState() { // For plot 1 manual markers
            lastMarkerPosition = { md: null, tvd: null };
            lastMarkerAyOffset = -40;
            // console.log("Manual Marker staggering state reset.");
        }
         function resetAutoStaggeringState() { // Reset state for plot 2 annotations
            lastAutoMarkerPosition = { md: null, tvd: null };
            lastAutoMarkerAyOffset = -40;
            // console.log("Auto-Marker staggering state reset.");
        }
        function updateRemoveButtonsState() { // Only affects plot 1 markers
            try {
                const annotationsExist = currentLayout && Array.isArray(currentLayout.annotations) && currentLayout.annotations.length > 0;
                removeLastMarkerButton.disabled = !annotationsExist;
                removeAllMarkersButton.disabled = !annotationsExist;
            } catch (err) {
                console.error("Error updating remove button state:", err);
            }
        }
        function clearPlot() {
            // console.log("Clearing plots and resetting state.");
            try {
                if (plotInstance) Plotly.purge(plotDiv);
                if (plotInstance2) Plotly.purge(plotDiv2);
                // console.log("Plotly plots purged.");
            } catch (purgeError) {
                console.error("Error purging Plotly plots:", purgeError);
            } finally {
                plotDiv.innerHTML = `<div class="flex items-center justify-center h-full text-gray-500">Upload an XLSX file to generate the plot.</div>`;
                plotDiv2.innerHTML = `<div></div>`;
                if(htmlPlotTitle) htmlPlotTitle.textContent = '';
                if(htmlPlotTitle2) htmlPlotTitle2.textContent = '';
                plotInstance = null;
                plotInstance2 = null;
                currentPlotData = { lineData: [], nearestPointsData: {}, dlsHighlightData: [], dlsSuperHighlightData: [], dlsRange: { min: null, max: null } };
                currentLayout = {};
                currentLayout2 = {};
                titleSection.disabled = true;
                markerSection.disabled = true;
                if(printButton) printButton.disabled = true;
                markerStatus.textContent = '';
                mdValueInput.value = '';
                markerTextInput.value = '';
                plotTitleInput.value = '';
                resetStaggeringState();
                resetAutoStaggeringState(); // Reset auto staggering
                updateRemoveButtonsState();
            }
        }


        // --- Core Logic Functions ---

        function processNsEw(value) { /* ... */ }
        function findNearestPoints(data) { /* ... */ }
        function processData(jsonData) { /* ... */ }
        function createPlots(plotData, initialManualAnnotations = []) { /* ... */ }

        // --- Core Logic Functions (Full Implementation) ---
        function processNsEw(value) {
            if (!value || typeof value !== 'string') return NaN;
            const parts = value.trim().split(' ');
            if (parts.length !== 2) return NaN;
            const directionStr = parts[0].toUpperCase();
            const number = parseFloat(parts[1]);
            if (isNaN(number)) return NaN;
            let directionMultiplier = 1;
            if (directionStr === 'S' || directionStr === 'W') directionMultiplier = -1;
            else if (directionStr !== 'N' && directionStr !== 'E') return NaN;
            return directionMultiplier * number;
        }
        function findNearestPoints(data) {
            // console.log("Finding nearest points...");
            const nearestTvdValues = [];
            const nearestMdValues = [];
            const hoverDepthValues = [];
            const hoverPlugNumbers = [];
            const depthData = data
                .filter(row => row.hasOwnProperty('Depth') && row.hasOwnProperty('Plug #'))
                .map(row => ({ depth: parseFloat(row['Depth']), plug: row['Plug #'] }))
                .filter(item => !isNaN(item.depth));

            if (depthData.length === 0) {
                console.warn("No valid 'Depth'/'Plug #' data found for scatter points.");
                return { nearestMdValues: [], nearestTvdValues: [], hoverDepthValues: [], hoverPlugNumbers: [] };
            }

            depthData.forEach(item => {
                const depth = item.depth;
                const plugNumber = item.plug;
                let minDifference = Infinity;
                let nearestMdRow = null;
                data.forEach((mdRow) => {
                    if (isNaN(mdRow['MD'])) return;
                    const difference = Math.abs(depth - mdRow['MD']);
                    if (difference < minDifference) {
                        minDifference = difference;
                        nearestMdRow = mdRow;
                    }
                });
                if (nearestMdRow && !isNaN(nearestMdRow['TVD']) && !isNaN(nearestMdRow['MD'])) {
                    nearestTvdValues.push(nearestMdRow['TVD']);
                    nearestMdValues.push(nearestMdRow['MD']);
                    hoverDepthValues.push(depth);
                    hoverPlugNumbers.push(plugNumber);
                } else {
                    // console.warn(`Could not find valid nearest MD row for Depth: ${depth}`);
                }
            });
            // console.log(`Found ${nearestMdValues.length} scatter points.`);
            return { nearestMdValues, nearestTvdValues, hoverDepthValues, hoverPlugNumbers };
        }
        function processData(jsonData) {
            // console.log("Processing XLSX data (incl. DLS & Filtering)...");
            if (!jsonData || jsonData.length === 0) throw new Error("XLSX data is empty.");

            const firstRow = jsonData[0];
            const requiredCols = ['TVD', 'MD', 'DLS'];
            const optionalScatterCols = ['Depth', 'Plug #'];
            requiredCols.forEach(col => { if (!(col in firstRow)) throw new Error(`Missing required column: '${col}'.`); });
            const hasScatterCols = optionalScatterCols.every(col => col in firstRow);
            if (!hasScatterCols) console.warn("Optional columns 'Depth' or 'Plug #' missing, scatter plot will not be generated.");

            let minDLS = Infinity;
            let maxDLS = -Infinity;

            const processedData = jsonData.map((row, index) => {
                 const tvd = parseFloat(row['TVD']);
                 const md = parseFloat(row['MD']);
                 const dls = parseFloat(row['DLS']);

                 if (isNaN(tvd) || isNaN(md) || isNaN(dls)) { return null; }

                 if (dls < minDLS) minDLS = dls;
                 if (dls > maxDLS) maxDLS = dls;

                 return {
                    TVD: tvd, MD: md, DLS: dls,
                    Depth: hasScatterCols ? parseFloat(row['Depth']) : undefined,
                    'Plug #': hasScatterCols ? row['Plug #'] : undefined,
                    NS_numeric: row.hasOwnProperty('NS') ? processNsEw(String(row['NS'] || '')) : undefined,
                    EW_numeric: row.hasOwnProperty('EW') ? processNsEw(String(row['EW'] || '')) : undefined,
                 };
            }).filter(row => row !== null);

            if (processedData.length === 0) throw new Error("No valid data rows found after processing (check TVD, MD, DLS columns).");

            if (minDLS === Infinity || maxDLS === -Infinity) { minDLS = 0; maxDLS = 1; }
            else if (minDLS === maxDLS) { minDLS = minDLS - 0.1; maxDLS = maxDLS + 0.1; }

            const nearestPoints = hasScatterCols ? findNearestPoints(processedData) : { nearestMdValues: [], nearestTvdValues: [], hoverDepthValues: [], hoverPlugNumbers: [] };
            const dlsHighlightData = processedData.filter(row => row.DLS > 1);
            const dlsSuperHighlightData = processedData.filter(row => row.DLS > 5);
            console.log(`Found ${dlsSuperHighlightData.length} points with DLS > 5 for annotations.`);

            // console.log("Data processing complete. DLS range:", minDLS, maxDLS);
            return {
                lineData: processedData,
                nearestPointsData: nearestPoints || { nearestMdValues: [], nearestTvdValues: [], hoverDepthValues: [], hoverPlugNumbers: [] },
                dlsHighlightData: dlsHighlightData,
                dlsSuperHighlightData: dlsSuperHighlightData,
                dlsRange: { min: minDLS, max: maxDLS }
            };
        }
        function createPlots(plotData, initialManualAnnotations = []) {
            // console.log("Attempting to create plots...");
            hideError();
            markerStatus.textContent = '';
            markerStatus.className = 'mt-1 text-xs text-gray-500 h-4';

            if (!plotData || !plotData.lineData || plotData.lineData.length === 0) {
                 showError("Cannot create plots: No valid line data available.");
                 console.error("createPlots called with invalid plotData:", plotData);
                 return;
            }
            const { lineData, nearestPointsData, dlsHighlightData, dlsSuperHighlightData, dlsRange } = plotData;
            const yAxisMinLimit = 2620;
            const xAxisMinLimit = 2650;

            // --- Plot 1: Main Plot (Well Path + Plugs) ---
            try {
                // console.log("Creating Plot 1...");
                const safeNearestPointsData = nearestPointsData && typeof nearestPointsData === 'object'
                    ? nearestPointsData
                    : { nearestMdValues: [], nearestTvdValues: [], hoverDepthValues: [], hoverPlugNumbers: [] };
                const { nearestMdValues, nearestTvdValues, hoverDepthValues, hoverPlugNumbers } = safeNearestPointsData;

                const traces1 = [];
                // 1a. Well Path Line
                traces1.push({
                    x: lineData.map(row => row.MD), y: lineData.map(row => row.TVD),
                    mode: 'lines', type: 'scatter', name: 'Well Path',
                    hovertemplate: 'MD: %{x:.2f} m<br>TVD: %{y:.2f} m<extra></extra>',
                    line: { color: '#D3D3D3', width: 8 }
                });
                // 1b. Plugs Scatter
                if (nearestMdValues && nearestMdValues.length > 0) {
                     console.log('Plot 1: Adding Plug # & Depth scatter trace with', nearestMdValues.length, 'points.');
                    traces1.push({
                        x: nearestMdValues, y: nearestTvdValues, mode: 'markers', type: 'scatter', name: 'Plug # & Depth',
                        marker: { color: 'black', size: 8, symbol: 'square' },
                        text: hoverDepthValues.map(d => d.toFixed(2)),
                        customdata: hoverPlugNumbers.map(pn => [pn]),
                        hovertemplate: '<b>Plug #: %{customdata[0]}</b><br>Depth: %{text} m<br>MD: %{x:.2f} m<br>TVD: %{y:.2f} m<extra></extra>'
                    });
                } else {
                     markerStatus.textContent = '(Note: "Plug # & Depth" data not found or invalid in file.)';
                     markerStatus.className = 'mt-1 text-xs text-gray-500 h-4';
                     console.log("Plot 1: No data for Plug # & Depth scatter trace.");
                }

                // Calculate Axis Ranges for Plot 1
                const allTvdValues1 = [...lineData.map(row => row.TVD), ...(nearestTvdValues || [])].filter(tvd => !isNaN(tvd));
                const allMdValues1 = [...lineData.map(row => row.MD), ...(nearestMdValues || [])].filter(md => !isNaN(md));
                let maxYtvd1 = -Infinity; if (allTvdValues1.length > 0) maxYtvd1 = Math.max(...allTvdValues1);
                let yAxisRange1 = null; let useAutorangeReversed1 = true;
                if (maxYtvd1 === -Infinity) { console.warn("Plot 1: No valid TVD data found."); }
                else if (maxYtvd1 <= yAxisMinLimit) { console.warn(`Plot 1: All TVD data is >= ${yAxisMinLimit}. Using autorange reversed.`); }
                else { const padding = (maxYtvd1 - yAxisMinLimit) * 0.05; yAxisRange1 = [maxYtvd1 + padding, yAxisMinLimit]; useAutorangeReversed1 = false; }
                let minMd1 = Infinity; let maxMd1 = -Infinity;
                if (allMdValues1.length > 0) { minMd1 = Math.min(...allMdValues1); maxMd1 = Math.max(...allMdValues1); }
                let xAxisRange1 = null; let useAutorangeX1 = true;
                if (minMd1 === Infinity) { console.warn("Plot 1: No valid MD data found."); }
                else if (minMd1 >= xAxisMinLimit) { console.warn(`Plot 1: All MD data is >= ${xAxisMinLimit}. Using autorange.`); }
                else { const padding = (maxMd1 - xAxisMinLimit) * 0.05; xAxisRange1 = [xAxisMinLimit, maxMd1 + padding]; useAutorangeX1 = false; }

                // Layout for Plot 1
                const layout1 = {
                    xaxis: { title: 'MD (m)', zeroline: true, gridcolor: '#e0e0e0', range: xAxisRange1, autorange: useAutorangeX1 ? true : undefined },
                    yaxis: { title: 'TVD (m)', zeroline: true, gridcolor: '#e0e0e0', range: yAxisRange1, autorange: useAutorangeReversed1 ? 'reversed' : undefined },
                    hovermode: 'closest', margin: { l: 60, r: 30, t: 30, b: 50 },
                    showlegend: true,
                    legend: { x: 1.02, y: 0, xanchor: 'left', yanchor: 'bottom' },
                    paper_bgcolor: 'rgb(249, 250, 251)', plot_bgcolor: 'rgb(249, 250, 251)',
                    annotations: initialManualAnnotations // Use only manually added annotations
                };
                currentLayout = layout1;
                const displayTitle1 = plotTitleInput.value.trim() || 'Well Path and Completions';

                // Render Plot 1
                if (!plotDiv) throw new Error("Plot 1 container element not found.");
                plotDiv.innerHTML = '';
                Plotly.newPlot(plotDiv, traces1, currentLayout, {responsive: true}).then(gd => {
                    plotInstance = gd;
                    if(htmlPlotTitle) htmlPlotTitle.textContent = displayTitle1;
                    plotTitleInput.value = displayTitle1;
                    titleSection.disabled = false; markerSection.disabled = false; updateRemoveButtonsState();
                }).catch(err => { throw err; });

            } catch (plot1Error) {
                 console.error("Error creating Plot 1:", plot1Error);
                 showError(`Failed to create main plot: ${plot1Error.message}`, plot1Error);
                 clearPlot(); return;
            }

             // --- Plot 2: DLS Highlights ---
            try {
                // console.log("Creating Plot 2 (DLS Highlights)...");
                const traces2 = [];
                const safeDlsRange = dlsRange && typeof dlsRange === 'object' && dlsRange.min != null && dlsRange.max != null ? dlsRange : { min: 0, max: 1};
                resetAutoStaggeringState(); // Reset staggering for auto-annotations
                const plot2Annotations = []; // Array for Plot 2's automatic annotations

                 // 2a. Background Well Path
                 traces2.push({
                    x: lineData.map(row => row.MD), y: lineData.map(row => row.TVD),
                    mode: 'lines', type: 'scatter',
                    name: 'Well Path (BG)', hoverinfo: 'skip',
                    line: { color: '#D3D3D3', width: 8 }
                 });

                // 2b. DLS > 1 Diamond Markers
                if (dlsHighlightData && dlsHighlightData.length > 0) {
                    traces2.push({
                        x: dlsHighlightData.map(row => row.MD), y: dlsHighlightData.map(row => row.TVD),
                        mode: 'markers', type: 'scatter',
                        name: 'DLS > 1',
                        hovertemplate: 'MD: %{x:.2f} m<br>DLS: %{marker.color:.2f}<extra></extra>',
                        marker: {
                            color: dlsHighlightData.map(row => row.DLS), colorscale: 'Hot', reversescale: true,
                            cmin: safeDlsRange.min, cmax: safeDlsRange.max, showscale: false,
                            symbol: 'diamond', size: 8
                        }
                    });
                } else {
                    plotDiv2.innerHTML = `<div class="flex items-center justify-center h-full text-gray-500 p-4">No data points found with DLS > 1.</div>`;
                }

                // Generate Automatic Annotations for DLS > 5
                if (dlsSuperHighlightData && dlsSuperHighlightData.length > 0) {
                    dlsSuperHighlightData.forEach(point => {
                        const positionMd = point.MD;
                        const positionTvd = point.TVD;
                        let currentAy = -40; const mdThreshold = 50; const tvdThreshold = 50; let isClose = false;
                        if (lastAutoMarkerPosition.md !== null) {
                            if (Math.abs(positionMd - lastAutoMarkerPosition.md) < mdThreshold && Math.abs(positionTvd - lastAutoMarkerPosition.tvd) < tvdThreshold) { isClose = true; }
                        }
                        if (isClose) { currentAy = (lastAutoMarkerAyOffset < 0) ? 50 : -40; } else { currentAy = -40; }
                        const annotationText = `<b>DLS: ${point.DLS.toFixed(2)}</b><br>MD: ${positionMd.toFixed(2)} m`;
                        plot2Annotations.push({
                            x: positionMd, y: positionTvd, xref: 'x', yref: 'y', text: annotationText,
                            showarrow: true, arrowhead: 2, ax: 40, ay: currentAy,
                            bgcolor: 'rgba(255, 69, 0, 0.7)', bordercolor: '#cc3700',
                            font: { size: 9, color: 'white' }, borderwidth: 1
                        });
                         lastAutoMarkerPosition = { md: positionMd, tvd: positionTvd }; lastAutoMarkerAyOffset = currentAy;
                    });
                }

                // Calculate Axis Ranges for Plot 2
                const allTvdValues2 = [...lineData.map(r => r.TVD), ...dlsHighlightData.map(r => r.TVD)].filter(tvd => !isNaN(tvd));
                const allMdValues2 = [...lineData.map(r => r.MD), ...dlsHighlightData.map(r => r.MD)].filter(md => !isNaN(md));
                let maxYtvd2 = -Infinity; if (allTvdValues2.length > 0) maxYtvd2 = Math.max(...allTvdValues2);
                let yAxisRange2 = null; let useAutorangeReversed2 = true;
                if (maxYtvd2 === -Infinity) { console.warn("Plot 2: No valid TVD data found."); }
                else if (maxYtvd2 <= yAxisMinLimit) { console.warn(`Plot 2: All TVD data is >= ${yAxisMinLimit}. Using autorange reversed.`); }
                else { const padding = (maxYtvd2 - yAxisMinLimit) * 0.05; yAxisRange2 = [maxYtvd2 + padding, yAxisMinLimit]; useAutorangeReversed2 = false; }
                let minMd2 = Infinity; let maxMd2 = -Infinity;
                if (allMdValues2.length > 0) { minMd2 = Math.min(...allMdValues2); maxMd2 = Math.max(...allMdValues2); }
                let xAxisRange2 = null; let useAutorangeX2 = true;
                if (minMd2 === Infinity) { console.warn("Plot 2: No valid MD data found."); }
                else if (minMd2 >= xAxisMinLimit) { console.warn(`Plot 2: All MD data is >= ${xAxisMinLimit}. Using autorange.`); }
                else { const padding = (maxMd2 - xAxisMinLimit) * 0.05; xAxisRange2 = [xAxisMinLimit, maxMd2 + padding]; useAutorangeX2 = false; }

                // Layout for Plot 2
                const layout2 = {
                    xaxis: { title: 'MD (m)', zeroline: true, gridcolor: '#e0e0e0', range: xAxisRange2, autorange: useAutorangeX2 ? true : undefined },
                    yaxis: { title: 'TVD (m)', zeroline: true, gridcolor: '#e0e0e0', range: yAxisRange2, autorange: useAutorangeReversed2 ? 'reversed' : undefined },
                    hovermode: 'closest', margin: { l: 60, r: 30, t: 30, b: 50 },
                    showlegend: true,
                    legend: { x: 1.02, y: 0, xanchor: 'left', yanchor: 'bottom' },
                    paper_bgcolor: 'rgb(249, 250, 251)', plot_bgcolor: 'rgb(249, 250, 251)',
                    annotations: plot2Annotations // Add the generated annotations
                };
                currentLayout2 = layout2;
                const displayTitle2 = "DLS > 1 Highlights";

                 // Render Plot 2
                if (traces2.length > 0) {
                    if (!plotDiv2) throw new Error("Plot 2 container element not found.");
                    plotDiv2.innerHTML = '';
                    // console.log("Plot 2 Traces:", traces2); // Removed log
                    // console.log("Plot 2 Layout:", layout2); // Removed log

                    Plotly.newPlot(plotDiv2, traces2, currentLayout2, {responsive: true}).then(gd => {
                        plotInstance2 = gd;
                        if(htmlPlotTitle2) htmlPlotTitle2.textContent = displayTitle2;
                    }).catch(err => { throw err; });
                } else {
                     plotDiv2.innerHTML = `<div class="flex items-center justify-center h-full text-gray-500 p-4">No data points found with DLS > 1.</div>`;
                }

            } catch (plot2Error) {
                console.error("Error creating Plot 2:", plot2Error);
                showError(`Failed to create DLS highlight plot: ${plot2Error.message}`, plot2Error);
                plotDiv2.innerHTML = `<div class="flex items-center justify-center h-full text-red-500 p-4">Failed to load DLS plot.</div>`;
            }

            if(printButton) printButton.disabled = false; // Enable print button

        }

        // --- Event Handlers ---

        function handleFileSelect(event) { /* ... */ }
        function handleUpdateTitle() { /* ... */ }
        function handleAddMarker() { /* ... */ }
        function handleRemoveLastMarker() { /* ... */ }
        function handleRemoveAllMarkers() { /* ... */ }
        function handlePrint() { /* ... */ }

        // --- Event Handlers (Full Implementation - Unchanged) ---
         function handleFileSelect(event) {
            // console.log("File selected."); // Removed
            const file = event.target.files[0];
            clearPlot();
            hideError();

            if (!file) { return; }
            if (!file.name.endsWith('.xlsx')) {
                 showError("Invalid file type. Please upload an .xlsx file.");
                 fileInput.value = ''; return;
            }

            showLoading("Reading file...");
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileData = e.target.result;
                    const workbook = XLSX.read(fileData, { type: 'binary' });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    // console.log("XLSX data read successfully."); // Removed

                    showLoading("Processing data...");
                    currentPlotData = processData(jsonData);

                    showLoading("Generating plots...");
                    createPlots(currentPlotData, []); // Pass empty array for initial manual annotations
                    clearLoading("Plots generated successfully.");

                } catch (error) {
                    console.error("Error during file processing or plotting:", error); // Keep error log
                    showError(`Operation failed: ${error.message}`, error);
                    clearLoading();
                    clearPlot();
                }
            };
            reader.onerror = function(e) {
                console.error("FileReader error:", e); // Keep error log
                showError("Error reading the file.", e);
                clearLoading();
                clearPlot();
            }
            reader.readAsBinaryString(file);
        }
        function handleUpdateTitle() {
            // console.log("Update Title button clicked."); // Removed
            if (!plotInstance) {
                 showError("Plot 1 not generated yet."); return;
            }
            const newTitle = plotTitleInput.value.trim();
            // console.log("Attempting to update HTML title 1 to:", newTitle); // Removed
            if (htmlPlotTitle) {
                htmlPlotTitle.textContent = newTitle;
                // console.log("HTML title 1 updated."); // Removed
                markerStatus.textContent = `Plot title updated.`;
                markerStatus.className = 'mt-1 text-xs text-blue-600 h-4';
                setTimeout(() => { if (markerStatus.textContent === 'Plot title updated.') markerStatus.textContent = ''; }, 3000);
            } else {
                 console.error("HTML title 1 element not found."); // Keep error log
                 showError("Could not find title 1 element to update.");
            }
        }
        function handleAddMarker() {
            // console.log("Add Marker button clicked."); // Removed
            if (!plotInstance || !currentPlotData?.lineData?.length || !currentLayout) {
                markerStatus.textContent = 'Load data and generate plot 1 first.';
                markerStatus.className = 'mt-1 text-xs text-red-500 h-4'; return;
            }

            const targetMd = parseFloat(mdValueInput.value);
            if (isNaN(targetMd)) {
                markerStatus.textContent = 'Valid MD value is required.';
                markerStatus.className = 'mt-1 text-xs text-red-500 h-4'; return;
            }

            const customText = markerTextInput.value.trim();
            const lineData = currentPlotData.lineData;

            let closestIndex = -1; let minDiff = Infinity;
            lineData.forEach((point, index) => {
                if (isNaN(point.MD)) return;
                const diff = Math.abs(point.MD - targetMd);
                if (diff < minDiff) { minDiff = diff; closestIndex = index; }
            });

            if (closestIndex === -1) {
                 markerStatus.textContent = 'Could not find point on well path for the entered MD.';
                 markerStatus.className = 'mt-1 text-xs text-red-500 h-4'; return;
            }

            const positionMd = lineData[closestIndex].MD;
            const positionTvd = lineData[closestIndex].TVD;

            let currentAy = -40; const mdThreshold = 50; const tvdThreshold = 50; let isClose = false;
            if (lastMarkerPosition.md !== null) {
                if (Math.abs(positionMd - lastMarkerPosition.md) < mdThreshold && Math.abs(positionTvd - lastMarkerPosition.tvd) < tvdThreshold) { isClose = true; }
            }
            if (isClose) { currentAy = (lastMarkerAyOffset < 0) ? 50 : -40; } else { currentAy = -40; }

            let annotationText = customText ? `<b>${customText}</b><br>MD: ${targetMd.toFixed(2)} m` : `<b>MD: ${targetMd.toFixed(2)} m</b>`;
            const newAnnotation = {
                x: positionMd, y: positionTvd, xref: 'x', yref: 'y', text: annotationText,
                showarrow: true, arrowhead: 2, ax: 40, ay: currentAy,
                bgcolor: 'rgba(135, 206, 235, 0.6)', bordercolor: '#4682B4', borderwidth: 1, font: { size: 10 }
            };

            if (!Array.isArray(currentLayout.annotations)) currentLayout.annotations = [];
            currentLayout.annotations.push(newAnnotation);

            Plotly.relayout(plotDiv, { annotations: currentLayout.annotations }).then(() => {
                 // console.log("Annotation added to Plot 1."); // Removed
                 lastMarkerPosition = { md: positionMd, tvd: positionTvd }; lastMarkerAyOffset = currentAy;
                 markerStatus.textContent = `Marker added for MD: ${targetMd.toFixed(2)}m.`;
                 markerStatus.className = 'mt-1 text-xs text-green-600 h-4';
                 updateRemoveButtonsState();
            }).catch(err => {
                 console.error("Plotly relayout error (add annotation):", err); // Keep error log
                 showError(`Failed to add marker: ${err.message}`, err);
                 currentLayout.annotations.pop(); updateRemoveButtonsState();
            });
        }
        function handleRemoveLastMarker() {
            // console.log("Remove Last button clicked."); // Removed
            if (!plotInstance || !currentLayout || !Array.isArray(currentLayout.annotations) || currentLayout.annotations.length === 0) {
                markerStatus.textContent = 'No markers to remove from Plot 1.';
                markerStatus.className = 'mt-1 text-xs text-gray-500 h-4'; return;
            }
            currentLayout.annotations.pop();
            resetStaggeringState();
            Plotly.relayout(plotDiv, { annotations: currentLayout.annotations }).then(() => {
                 // console.log("Last annotation removed from Plot 1."); // Removed
                 markerStatus.textContent = 'Last marker removed.';
                 markerStatus.className = 'mt-1 text-xs text-blue-600 h-4';
                 updateRemoveButtonsState();
            }).catch(err => {
                 console.error("Plotly relayout error (remove last):", err); // Keep error log
                 showError(`Failed to remove last marker: ${err.message}`, err);
            });
        }
        function handleRemoveAllMarkers() {
            // console.log("Remove All button clicked."); // Removed
             if (!plotInstance || !currentLayout || !Array.isArray(currentLayout.annotations) || currentLayout.annotations.length === 0) {
                markerStatus.textContent = 'No markers to remove from Plot 1.';
                markerStatus.className = 'mt-1 text-xs text-gray-500 h-4'; return;
             }
             currentLayout.annotations = [];
             resetStaggeringState();
             Plotly.relayout(plotDiv, { annotations: currentLayout.annotations }).then(() => {
                 // console.log("All annotations removed from Plot 1."); // Removed
                 markerStatus.textContent = 'All markers removed.';
                 markerStatus.className = 'mt-1 text-xs text-blue-600 h-4';
                 updateRemoveButtonsState();
             }).catch(err => {
                 console.error("Plotly relayout error (remove all):", err); // Keep error log
                 showError(`Failed to remove all markers: ${err.message}`, err);
             });
        }
        function handlePrint() {
            // console.log("Print button clicked."); // Removed
            if (!plotInstance) {
                showError("Please generate plots before printing.");
                return;
            }
            window.print();
        }


        // --- Initial Setup ---
        // console.log("Adding initial event listeners."); // Removed
        fileInput.addEventListener('change', handleFileSelect, false);
        updateTitleButton.addEventListener('click', handleUpdateTitle, false);
        addMarkerButton.addEventListener('click', handleAddMarker, false);
        removeLastMarkerButton.addEventListener('click', handleRemoveLastMarker, false);
        removeAllMarkersButton.addEventListener('click', handleRemoveAllMarkers, false);
        printButton.addEventListener('click', handlePrint, false);

        titleSection.disabled = true;
        markerSection.disabled = true;
        printButton.disabled = true;
        updateRemoveButtonsState();
        // console.log("Initial setup complete."); // Removed

    </script>

</body>
</html>
